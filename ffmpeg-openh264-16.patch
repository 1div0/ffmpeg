diff -Naur ffmpeg-3.1.1.old/configure ffmpeg-3.1.1/configure
--- ffmpeg-3.1.1.old/configure	2016-08-05 17:45:58.609584928 +0200
+++ ffmpeg-3.1.1/configure	2016-08-05 17:47:03.183876565 +0200
@@ -2766,6 +2766,8 @@
 libopencore_amrnb_encoder_deps="libopencore_amrnb"
 libopencore_amrnb_encoder_select="audio_frame_queue"
 libopencore_amrwb_decoder_deps="libopencore_amrwb"
+libopenh264_decoder_deps="libopenh264"
+libopenh264_decoder_select="h264_mp4toannexb_bsf"
 libopenh264_encoder_deps="libopenh264"
 libopenjpeg_decoder_deps="libopenjpeg"
 libopenjpeg_encoder_deps="libopenjpeg"
diff -Naur ffmpeg-3.1.1.old/doc/general.texi ffmpeg-3.1.1/doc/general.texi
--- ffmpeg-3.1.1.old/doc/general.texi	2016-08-05 17:45:58.616585068 +0200
+++ ffmpeg-3.1.1/doc/general.texi	2016-08-05 17:47:03.184876585 +0200
@@ -103,12 +103,19 @@
 
 @section OpenH264
 
-FFmpeg can make use of the OpenH264 library for H.264 encoding.
+FFmpeg can make use of the OpenH264 library for H.264 encoding and decoding.
 
 Go to @url{http://www.openh264.org/} and follow the instructions for
 installing the library. Then pass @code{--enable-libopenh264} to configure to
 enable it.
 
+For decoding, this library is much more limited than the built-in decoder
+in libavcodec; currently, this library lacks support for decoding B-frames
+and some other main/high profile features. (It currently only supports
+constrained baseline profile and CABAC.) Using it is mostly useful for
+testing and for taking advantage of Cisco's patent portfolio license
+(@url{http://www.openh264.org/BINARY_LICENSE.txt}).
+
 @section x264
 
 FFmpeg can make use of the x264 library for H.264 encoding.
diff -Naur ffmpeg-3.1.1.old/libavcodec/allcodecs.c ffmpeg-3.1.1/libavcodec/allcodecs.c
--- ffmpeg-3.1.1.old/libavcodec/allcodecs.c	2016-08-05 17:45:58.588584508 +0200
+++ ffmpeg-3.1.1/libavcodec/allcodecs.c	2016-08-05 17:47:03.185876605 +0200
@@ -622,7 +622,7 @@
 
     /* external libraries, that shouldn't be used by default if one of the
      * above is available */
-    REGISTER_ENCODER(LIBOPENH264,       libopenh264);
+    REGISTER_ENCDEC (LIBOPENH264,       libopenh264);
     REGISTER_DECODER(H264_CUVID,        h264_cuvid);
     REGISTER_ENCODER(H264_NVENC,        h264_nvenc);
     REGISTER_ENCODER(H264_OMX,          h264_omx);
diff -Naur ffmpeg-3.1.1.old/libavcodec/libopenh264.c ffmpeg-3.1.1/libavcodec/libopenh264.c
--- ffmpeg-3.1.1.old/libavcodec/libopenh264.c	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-3.1.1/libavcodec/libopenh264.c	2016-08-05 17:47:03.185876605 +0200
@@ -0,0 +1,62 @@
+/*
+ * OpenH264 shared utils
+ * Copyright (C) 2014 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <string.h>
+#include <wels/codec_api.h>
+#include <wels/codec_ver.h>
+
+#include "libavutil/log.h"
+
+#include "libopenh264.h"
+
+// Convert libopenh264 log level to equivalent ffmpeg log level.
+static int libopenh264_to_ffmpeg_log_level(int libopenh264_log_level)
+{
+    if      (libopenh264_log_level >= WELS_LOG_DETAIL)  return AV_LOG_TRACE;
+    else if (libopenh264_log_level >= WELS_LOG_DEBUG)   return AV_LOG_DEBUG;
+    else if (libopenh264_log_level >= WELS_LOG_INFO)    return AV_LOG_VERBOSE;
+    else if (libopenh264_log_level >= WELS_LOG_WARNING) return AV_LOG_WARNING;
+    else if (libopenh264_log_level >= WELS_LOG_ERROR)   return AV_LOG_ERROR;
+    else                                                return AV_LOG_QUIET;
+}
+
+void ff_libopenh264_trace_callback(void *ctx, int level, const char *msg)
+{
+    // The message will be logged only if the requested EQUIVALENT ffmpeg log level is
+    // less than or equal to the current ffmpeg log level.
+    int equiv_ffmpeg_log_level = libopenh264_to_ffmpeg_log_level(level);
+    av_log(ctx, equiv_ffmpeg_log_level, "%s\n", msg);
+}
+
+int ff_libopenh264_check_version(void *logctx)
+{
+    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion
+    // function (for functions returning larger structs), thus skip the check in those
+    // configurations.
+#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)
+    OpenH264Version libver = WelsGetCodecVersion();
+    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {
+        av_log(logctx, AV_LOG_ERROR, "Incorrect library version loaded\n");
+        return AVERROR(EINVAL);
+    }
+#endif
+    return 0;
+}
diff -Naur ffmpeg-3.1.1.old/libavcodec/libopenh264dec.c ffmpeg-3.1.1/libavcodec/libopenh264dec.c
--- ffmpeg-3.1.1.old/libavcodec/libopenh264dec.c	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-3.1.1/libavcodec/libopenh264dec.c	2016-08-05 17:47:59.000993039 +0200
@@ -0,0 +1,245 @@
+/*
+ * OpenH264 video decoder
+ * Copyright (C) 2016 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <wels/codec_api.h>
+#include <wels/codec_ver.h>
+
+#include "libavutil/common.h"
+#include "libavutil/fifo.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/mathematics.h"
+#include "libavutil/opt.h"
+
+#include "avcodec.h"
+#include "internal.h"
+#include "libopenh264.h"
+
+typedef struct SVCContext {
+    ISVCDecoder *decoder;
+    AVBSFContext *bsf;
+    AVFifoBuffer *packet_fifo;
+    AVPacket pkt_filtered;
+} SVCContext;
+
+static av_cold int svc_decode_close(AVCodecContext *avctx)
+{
+    SVCContext *s = avctx->priv_data;
+    AVPacket pkt;
+
+    if (s->decoder)
+        WelsDestroyDecoder(s->decoder);
+
+    while (s->packet_fifo && av_fifo_size(s->packet_fifo) >= sizeof(pkt)) {
+        av_fifo_generic_read(s->packet_fifo, &pkt, sizeof(pkt), NULL);
+        av_packet_unref(&pkt);
+    }
+
+    av_bsf_free(&s->bsf);
+    av_packet_unref(&s->pkt_filtered);
+    av_fifo_free(s->packet_fifo);
+
+    return 0;
+}
+
+static av_cold int svc_decode_init(AVCodecContext *avctx)
+{
+    SVCContext *s = avctx->priv_data;
+    SDecodingParam param = { 0 };
+    int err;
+    int log_level;
+    WelsTraceCallback callback_function;
+
+    if ((err = ff_libopenh264_check_version(avctx)) < 0)
+        return err;
+
+    s->packet_fifo = av_fifo_alloc(sizeof(AVPacket));
+    if (!s->packet_fifo) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    if (WelsCreateDecoder(&s->decoder)) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to create decoder\n");
+        err = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // Pass all libopenh264 messages to our callback, to allow ourselves to filter them.
+    log_level = WELS_LOG_DETAIL;
+    callback_function = ff_libopenh264_trace_callback;
+    (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_LEVEL, &log_level);
+    (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);
+    (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);
+
+#if !OPENH264_VER_AT_LEAST(1, 6)
+    param.eOutputColorFormat = videoFormatI420;
+#endif
+    param.eEcActiveIdc       = ERROR_CON_DISABLE;
+    param.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_DEFAULT;
+
+    if ((*s->decoder)->Initialize(s->decoder, &param) != cmResultSuccess) {
+        av_log(avctx, AV_LOG_ERROR, "Initialize failed\n");
+        err = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+
+fail:
+    return err;
+}
+
+static int init_bsf(AVCodecContext *avctx)
+{
+    SVCContext *s = avctx->priv_data;
+    const AVBitStreamFilter *filter;
+    int ret;
+
+    if (s->bsf)
+        return 0;
+
+    // If the input stream already is annex b, this BSF only passes the
+    // packets through unchanged.
+    filter = av_bsf_get_by_name("h264_mp4toannexb");
+    if (!filter)
+        return AVERROR_BUG;
+
+    ret = av_bsf_alloc(filter, &s->bsf);
+    if (ret < 0)
+        return ret;
+
+    ret = avcodec_parameters_from_context(s->bsf->par_in, avctx);
+    if (ret < 0)
+        return ret;
+
+    s->bsf->time_base_in = avctx->time_base;
+
+    ret = av_bsf_init(s->bsf);
+    if (ret < 0)
+        return ret;
+
+    return ret;
+}
+
+static int svc_decode_frame(AVCodecContext *avctx, void *data,
+                            int *got_frame, AVPacket *avpkt)
+{
+    SVCContext *s = avctx->priv_data;
+    SBufferInfo info = { 0 };
+    uint8_t* ptrs[3];
+    int linesize[3];
+    AVFrame *avframe = data;
+    int ret;
+    DECODING_STATE state;
+
+    if ((ret = init_bsf(avctx)) < 0)
+        return ret;
+
+    if (avpkt->size) {
+        AVPacket input_ref = { 0 };
+        if (av_fifo_space(s->packet_fifo) < sizeof(input_ref)) {
+            ret = av_fifo_realloc2(s->packet_fifo,
+                                   av_fifo_size(s->packet_fifo) + sizeof(input_ref));
+            if (ret < 0)
+                return ret;
+        }
+
+        ret = av_packet_ref(&input_ref, avpkt);
+        if (ret < 0)
+            return ret;
+        av_fifo_generic_write(s->packet_fifo, &input_ref, sizeof(input_ref), NULL);
+    }
+
+    while (!*got_frame) {
+        /* prepare the input data -- convert to Annex B if needed */
+        if (s->pkt_filtered.size <= 0) {
+            AVPacket input_ref;
+
+            /* no more data */
+            if (av_fifo_size(s->packet_fifo) < sizeof(AVPacket))
+                return avpkt->size ? avpkt->size : 0;
+
+            av_packet_unref(&s->pkt_filtered);
+
+            av_fifo_generic_read(s->packet_fifo, &input_ref, sizeof(input_ref), NULL);
+            ret = av_bsf_send_packet(s->bsf, &input_ref);
+            if (ret < 0) {
+                av_packet_unref(&input_ref);
+                return ret;
+            }
+
+            ret = av_bsf_receive_packet(s->bsf, &s->pkt_filtered);
+            if (ret < 0)
+                av_packet_move_ref(&s->pkt_filtered, &input_ref);
+            else
+                av_packet_unref(&input_ref);
+        }
+
+        state = (*s->decoder)->DecodeFrame2(s->decoder, s->pkt_filtered.data, s->pkt_filtered.size, ptrs, &info);
+        s->pkt_filtered.size = 0;
+        if (state != dsErrorFree) {
+            av_log(avctx, AV_LOG_ERROR, "DecodeFrame2 failed\n");
+            return AVERROR_UNKNOWN;
+        }
+        if (info.iBufferStatus != 1) {
+            av_log(avctx, AV_LOG_DEBUG, "No frame produced\n");
+            continue;
+        }
+
+        ret = ff_set_dimensions(avctx, info.UsrData.sSystemBuffer.iWidth, info.UsrData.sSystemBuffer.iHeight);
+        if (ret < 0)
+            return ret;
+        // The decoder doesn't (currently) support decoding into a user
+        // provided buffer, so do a copy instead.
+        if (ff_get_buffer(avctx, avframe, 0) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Unable to allocate buffer\n");
+            return AVERROR(ENOMEM);
+        }
+
+        linesize[0] = info.UsrData.sSystemBuffer.iStride[0];
+        linesize[1] = linesize[2] = info.UsrData.sSystemBuffer.iStride[1];
+        av_image_copy(avframe->data, avframe->linesize, (const uint8_t **) ptrs, linesize, avctx->pix_fmt, avctx->width, avctx->height);
+
+        avframe->pts     = s->pkt_filtered.pts;
+        avframe->pkt_dts = s->pkt_filtered.dts;
+        avframe->pkt_pts = s->pkt_filtered.pts;
+
+        *got_frame = 1;
+    }
+    return avpkt->size;
+}
+
+AVCodec ff_libopenh264_decoder = {
+    .name           = "libopenh264",
+    .long_name      = NULL_IF_CONFIG_SMALL("OpenH264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_H264,
+    .priv_data_size = sizeof(SVCContext),
+    .init           = svc_decode_init,
+    .decode         = svc_decode_frame,
+    .close          = svc_decode_close,
+    // The decoder doesn't currently support B-frames, and the decoder's API
+    // doesn't support reordering/delay, but the BSF could incur delay.
+    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
+};
diff -Naur ffmpeg-3.1.1.old/libavcodec/libopenh264enc.c ffmpeg-3.1.1/libavcodec/libopenh264enc.c
--- ffmpeg-3.1.1.old/libavcodec/libopenh264enc.c	2016-08-05 17:45:58.591584568 +0200
+++ ffmpeg-3.1.1/libavcodec/libopenh264enc.c	2016-08-05 17:47:59.000993039 +0200
@@ -31,6 +31,11 @@
 
 #include "avcodec.h"
 #include "internal.h"
+#include "libopenh264.h"
+
+#if !OPENH264_VER_AT_LEAST(1, 6)
+#define SM_SIZELIMITED_SLICE SM_DYN_SLICE
+#endif
 
 typedef struct SVCContext {
     const AVClass *av_class;
@@ -44,18 +49,23 @@
     int cabac;
 } SVCContext;
 
-#define OPENH264_VER_AT_LEAST(maj, min) \
-    ((OPENH264_MAJOR  > (maj)) || \
-     (OPENH264_MAJOR == (maj) && OPENH264_MINOR >= (min)))
-
 #define OFFSET(x) offsetof(SVCContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
+#if OPENH264_VER_AT_LEAST(1, 6)
+    { "slice_mode", "set slice mode", OFFSET(slice_mode), AV_OPT_TYPE_INT, { .i64 = SM_FIXEDSLCNUM_SLICE }, SM_SINGLE_SLICE, SM_RESERVED, VE, "slice_mode" },
+#else
     { "slice_mode", "set slice mode", OFFSET(slice_mode), AV_OPT_TYPE_INT, { .i64 = SM_AUTO_SLICE }, SM_SINGLE_SLICE, SM_RESERVED, VE, "slice_mode" },
+#endif
         { "fixed", "a fixed number of slices", 0, AV_OPT_TYPE_CONST, { .i64 = SM_FIXEDSLCNUM_SLICE }, 0, 0, VE, "slice_mode" },
+#if OPENH264_VER_AT_LEAST(1, 6)
+        { "dyn", "Size limited (compatibility name)", 0, AV_OPT_TYPE_CONST, { .i64 = SM_SIZELIMITED_SLICE }, 0, 0, VE, "slice_mode" },
+        { "sizelimited", "Size limited", 0, AV_OPT_TYPE_CONST, { .i64 = SM_SIZELIMITED_SLICE }, 0, 0, VE, "slice_mode" },
+#else
         { "rowmb", "one slice per row of macroblocks", 0, AV_OPT_TYPE_CONST, { .i64 = SM_ROWMB_SLICE }, 0, 0, VE, "slice_mode" },
         { "auto", "automatic number of slices according to number of threads", 0, AV_OPT_TYPE_CONST, { .i64 = SM_AUTO_SLICE }, 0, 0, VE, "slice_mode" },
         { "dyn", "Dynamic slicing", 0, AV_OPT_TYPE_CONST, { .i64 = SM_DYN_SLICE }, 0, 0, VE, "slice_mode" },
+#endif
     { "loopfilter", "enable loop filter", OFFSET(loopfilter), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 1, VE },
     { "profile", "set profile restrictions", OFFSET(profile), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },
     { "max_nal_size", "set maximum NAL size in bytes", OFFSET(max_nal_size), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
@@ -68,31 +78,6 @@
     "libopenh264enc", av_default_item_name, options, LIBAVUTIL_VERSION_INT
 };
 
-// Convert libopenh264 log level to equivalent ffmpeg log level.
-static int libopenh264_to_ffmpeg_log_level(int libopenh264_log_level)
-{
-    if      (libopenh264_log_level >= WELS_LOG_DETAIL)  return AV_LOG_TRACE;
-    else if (libopenh264_log_level >= WELS_LOG_DEBUG)   return AV_LOG_DEBUG;
-    else if (libopenh264_log_level >= WELS_LOG_INFO)    return AV_LOG_VERBOSE;
-    else if (libopenh264_log_level >= WELS_LOG_WARNING) return AV_LOG_WARNING;
-    else if (libopenh264_log_level >= WELS_LOG_ERROR)   return AV_LOG_ERROR;
-    else                                                return AV_LOG_QUIET;
-}
-
-// This function will be provided to the libopenh264 library.  The function will be called
-// when libopenh264 wants to log a message (error, warning, info, etc.).  The signature for
-// this function (defined in .../codec/api/svc/codec_api.h) is:
-//
-//        typedef void (*WelsTraceCallback) (void* ctx, int level, const char* string);
-
-static void libopenh264_trace_callback(void *ctx, int level, const char *msg)
-{
-    // The message will be logged only if the requested EQUIVALENT ffmpeg log level is
-    // less than or equal to the current ffmpeg log level.
-    int equiv_ffmpeg_log_level = libopenh264_to_ffmpeg_log_level(level);
-    av_log(ctx, equiv_ffmpeg_log_level, "%s\n", msg);
-}
-
 static av_cold int svc_encode_close(AVCodecContext *avctx)
 {
     SVCContext *s = avctx->priv_data;
@@ -108,21 +93,15 @@
 {
     SVCContext *s = avctx->priv_data;
     SEncParamExt param = { 0 };
-    int err = AVERROR_UNKNOWN;
+    int err;
     int log_level;
     WelsTraceCallback callback_function;
     AVCPBProperties *props;
 
-    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion
-    // function (for functions returning larger structs), thus skip the check in those
-    // configurations.
-#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)
-    OpenH264Version libver = WelsGetCodecVersion();
-    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {
-        av_log(avctx, AV_LOG_ERROR, "Incorrect library version loaded\n");
-        return AVERROR(EINVAL);
-    }
-#endif
+    if ((err = ff_libopenh264_check_version(avctx)) < 0)
+        return err;
+    // Use a default error for multiple error paths below
+    err = AVERROR_UNKNOWN;
 
     if (WelsCreateSVCEncoder(&s->encoder)) {
         av_log(avctx, AV_LOG_ERROR, "Unable to create encoder\n");
@@ -134,7 +113,7 @@
     (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level);
 
     // Set the logging callback function to one that uses av_log() (see implementation above).
-    callback_function = (WelsTraceCallback) libopenh264_trace_callback;
+    callback_function = (WelsTraceCallback) ff_libopenh264_trace_callback;
     (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);
 
     // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to av_log().
@@ -193,15 +172,24 @@
         s->slice_mode = SM_FIXEDSLCNUM_SLICE;
 
     if (s->max_nal_size)
-        s->slice_mode = SM_DYN_SLICE;
+        s->slice_mode = SM_SIZELIMITED_SLICE;
 
+#if OPENH264_VER_AT_LEAST(1, 6)
+    param.sSpatialLayers[0].sSliceArgument.uiSliceMode = s->slice_mode;
+    param.sSpatialLayers[0].sSliceArgument.uiSliceNum  = avctx->slices;
+#else
     param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;
     param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;
+#endif
 
-    if (s->slice_mode == SM_DYN_SLICE) {
+    if (s->slice_mode == SM_SIZELIMITED_SLICE) {
         if (s->max_nal_size){
             param.uiMaxNalSize = s->max_nal_size;
+#if OPENH264_VER_AT_LEAST(1, 6)
+            param.sSpatialLayers[0].sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;
+#else
             param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;
+#endif
         } else {
             av_log(avctx, AV_LOG_ERROR, "Invalid -max_nal_size, "
                    "specify a valid max_nal_size to use -slice_mode dyn\n");
diff -Naur ffmpeg-3.1.1.old/libavcodec/libopenh264.h ffmpeg-3.1.1/libavcodec/libopenh264.h
--- ffmpeg-3.1.1.old/libavcodec/libopenh264.h	1970-01-01 01:00:00.000000000 +0100
+++ ffmpeg-3.1.1/libavcodec/libopenh264.h	2016-08-05 17:47:03.186876625 +0200
@@ -0,0 +1,39 @@
+/*
+ * OpenH264 shared utils
+ * Copyright (C) 2014 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_LIBOPENH264_H
+#define AVCODEC_LIBOPENH264_H
+
+#define OPENH264_VER_AT_LEAST(maj, min) \
+    ((OPENH264_MAJOR  > (maj)) || \
+     (OPENH264_MAJOR == (maj) && OPENH264_MINOR >= (min)))
+
+// This function will be provided to the libopenh264 library.  The function will be called
+// when libopenh264 wants to log a message (error, warning, info, etc.).  The signature for
+// this function (defined in .../codec/api/svc/codec_api.h) is:
+//
+//        typedef void (*WelsTraceCallback) (void* ctx, int level, const char* string);
+
+void ff_libopenh264_trace_callback(void *ctx, int level, const char *msg);
+
+int ff_libopenh264_check_version(void *logctx);
+
+#endif /* AVCODEC_LIBOPENH264_H */
diff -Naur ffmpeg-3.1.1.old/libavcodec/Makefile ffmpeg-3.1.1/libavcodec/Makefile
--- ffmpeg-3.1.1.old/libavcodec/Makefile	2016-08-05 17:45:58.593584608 +0200
+++ ffmpeg-3.1.1/libavcodec/Makefile	2016-08-05 17:47:03.185876605 +0200
@@ -864,7 +864,8 @@
 OBJS-$(CONFIG_LIBOPENCORE_AMRNB_DECODER)  += libopencore-amr.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRNB_ENCODER)  += libopencore-amr.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRWB_DECODER)  += libopencore-amr.o
-OBJS-$(CONFIG_LIBOPENH264_ENCODER)        += libopenh264enc.o
+OBJS-$(CONFIG_LIBOPENH264_DECODER)        += libopenh264dec.o libopenh264.o
+OBJS-$(CONFIG_LIBOPENH264_ENCODER)        += libopenh264enc.o libopenh264.o
 OBJS-$(CONFIG_LIBOPENJPEG_DECODER)        += libopenjpegdec.o
 OBJS-$(CONFIG_LIBOPENJPEG_ENCODER)        += libopenjpegenc.o
 OBJS-$(CONFIG_LIBOPUS_DECODER)            += libopusdec.o libopus.o     \
